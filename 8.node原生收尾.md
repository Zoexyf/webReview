#### 流—连续

之前读文件的一般操作：先将文件读取到内存里面，再一次性将文件数据发送出去

缺点：1.太占用内存 2.资源使用不均匀

```javascript
fs.readFile('www/1.html',(err,buffer)=>{
	res.write(buffer)
})
//能够将文件读取；
//缺点：先将文件读取到内存里面，再一次性将文件数据发送出去，1.太占用内存  2.资源使用不均匀
```

需求：读一块儿 ，发一块

优点：保证内存占用充裕，读与发同时资源使用均匀

#####文件流

```javascript
const fs=require('fs');

let rs=fs.createReadStream('demo.jpg');
let ws=fs.createWriteStream('demo.copy.txt');

rs.pipe(ws);
//注意方向不能变，流是受读写双方影响的，并且读rs是占优势
//流自动处理

//读事件 error
rs.on('error', err=>{
  console.log(err);
});

//写事件 finish
ws.on('finish', ()=>{
  console.log('完成');
});

```

问题：数据库也可以流操作吗？

答：数据库是一个典型的面向块的，没法对数据库进行直接的流操作，

问题：流的大小可以设置吗？

答：不用设置，系统会根据实际情况对流的大小进行自适应调节

##### 读写流

使用场景：文件压缩；加密

zlib模块:node自带(所有语言基本都有zlib模块)，主要是用来创建压缩用的对象，执行压缩的功能

zlib.createGzip()

```javascript
const fs=require('fs');
const zlib=require('zlib');

let rs=fs.createReadStream('1.txt');
let gz=zlib.createGzip();
let ws=fs.createWriteStream('1.txt.gz');
//注意此处文件拓展名

rs.pipe(gz).pipe(ws);
//添加中间gz部分：读-压缩-写入

rs.on('error', err=>{
  console.log(err);
});

ws.on('finish', ()=>{
  console.log('完成');
});

```



#### 启动器

node server.js

服务器端启动nodejs需要一个启动器
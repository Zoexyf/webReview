#### 流—连续

之前读文件的一般操作：先将文件读取到内存里面，再一次性将文件数据发送出去

缺点：1.太占用内存 2.资源使用不均匀

```javascript
fs.readFile('www/1.html',(err,buffer)=>{
	res.write(buffer)
})
//能够将文件读取；
//缺点：先将文件读取到内存里面，再一次性将文件数据发送出去，1.太占用内存  2.资源使用不均匀
```

需求：读一块儿 ，发一块

优点：保证内存占用充裕，读与发同时资源使用均匀

#####文件流

```javascript
const fs=require('fs');

let rs=fs.createReadStream('demo.jpg');
let ws=fs.createWriteStream('demo.copy.txt');

rs.pipe(ws);
//注意方向不能变，流是受读写双方影响的，并且读rs是占优势
//流自动处理

//读事件 error
rs.on('error', err=>{
  console.log(err);
});

//写事件 finish
ws.on('finish', ()=>{
  console.log('完成');
});

```

问题：数据库也可以流操作吗？

答：数据库是一个典型的面向块的，没法对数据库进行直接的流操作，

问题：流的大小可以设置吗？

答：不用设置，系统会根据实际情况对流的大小进行自适应调节

##### 读写流

使用场景：文件压缩；加密

zlib模块:node自带(所有语言基本都有zlib模块)，主要是用来创建压缩用的对象，执行压缩的功能

zlib.createGzip()

```javascript
const fs=require('fs');
const zlib=require('zlib');

let rs=fs.createReadStream('1.txt');
let gz=zlib.createGzip();
let ws=fs.createWriteStream('1.txt.gz');
//注意此处文件拓展名

rs.pipe(gz).pipe(ws);
//添加中间gz部分：读-压缩-写入

rs.on('error', err=>{
  console.log(err);
});

ws.on('finish', ()=>{
  console.log('完成');
});

```

服务器server.js

```javascript
const http=require('http');
const zlib=require('zlib');
const url=require('url');
const fs=require('fs');

http.createServer((req, res)=>{
  let {pathname}=url.parse(req.url, true);
  let filepath='www'+pathname;
//应该先检查文件是否存在，再进行数据传输  fs.stat 该方法检查文件属性，可以用来检查文件是否存在
  fs.stat(filepath, (err, stat)=>{
    console.log(err);
    if(err){
      //res.setHeader('content-encoding', 'deflate');
      //deflate 普通二进制数组
      res.writeHeader(404);
      res.write('not found');
      res.end();
    }else{
      let rs=fs.createReadStream(filepath);
      rs.on('error', err=>{});//error用来检查是否读错数据，防止服务器错了崩了
      res.setHeader('content-encoding', 'gzip');
      let gz=zlib.createGzip();
      rs.pipe(gz).pipe(res);
    }
  });
}).listen(8080);

```



#### 启动器

node server.js

服务器端启动nodejs需要一个启动器

启动器可以帮助应用保持启动状态，不用启动器的话窗口一关，服务器一关启动器直接就停止；以及服务器重启也可以帮助重新启动这个服务

##### forver

+ `npm i forver -g`
+ `forver start server.js`
+ `forver list`检查启动的
+ `forver restart server.js`
+ `forver stop xxx.js`
+ `forver stopall`

+ `forver start xxx.js -l c:/a.log -e c:/err.log -a `
  + -l 值console.log
  + -e指错误输出到
  + -o指普通输出
  + -a指保留之前输出

#### 路由

1.合在一块儿用

2.router，本质是个json;将请求分开

'/login'=>function(){}

'reg'=>function(){}

'*'=>read

问题：ES6语法 ...展开对象，相当于Object.assign复制
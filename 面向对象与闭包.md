## 面向对象与闭包

### 面向对象

+ 语言发展顺序

  机器语言 -> 汇编 -> 低级语言(面向过程) -> 高级语言(面向对象) -> 模块 -> 框架 -> API

+ 面向对象特性：
  1.封装性  Date ，
  2.继承性
  3.多态性，强类型语言（java）体现比较多；js是一种弱类型的语言

#### ES5与ES6中对象的区别

ES5中类的实现

```javascript
   //es5中既是类又是构造函数，
    function Person(name, age){
      this.name=name;
      this.age=age;
    }
    //类既要用属性和方法，方法写在函数（类）的外面
    //prototype修改某个类的原型，往上面添加方法
    Person.prototype.show=function (){
      alert(this.name);
      alert(this.age);
    };
    //问题：不统一；

    function Worker(name, age, job){
      Person.call(this, name, age);
      this.job=job;
    }

    Worker.prototype=new Person();
    Worker.prototype.constructor=Worker;

    Worker.prototype.showJob=function (){
      alert(this.job);
    };

    let w=new Worker('blue', 18, '打杂的');

    w.show();
    w.showJob();
```

ES6中类的实现

```javascript
  //解决方法 直接class ，constructor（构造函数，构造器）
    class Person{
      constructor(name, age){
        this.name=name;
        this.age=age;
      }

      show(){
        alert(this.name);
        alert(this.age);
      }
    }

    class Worker extends Person{
      constructor(name, age, job){
        super(name, age);
        this.job=job;
      }

      showJob(){
        alert(this.job);
      }
    }

    let w=new Worker('blue', 18, '打杂的');

    w.show();
    w.showJob();
```

ES6中主要增加

+ class

+ constructor

+ extends 

+ super

+ ```javascript
  class xxx extends xx{
    constructor(){
      super()
    }
  
    show(){
  
    }
  }
  
  ```

--------------------------------------------------------------------------------



### 闭包

+ GC：垃圾回收；

  C语言自己申请空间释放空间 ，忘记释放导致内存泄漏问题

+ 闭包的核心：

  1.底层：栈
  2.高层：函数当作对象处理

  闭包——留着别删

理解：每次调用一个函数的时候都会分配一个堆栈的空间，所有的函数里的局部变量都会保存在这个栈里面；函数结束的时候这个堆栈会进行回收；闭包可以解决这个堆栈不回收的问题；

Java里面不能存在独立的方法，他一定是存在某一个对象上面，不论静态还是动态；JavaScript中只要调用函数，会生成对象，这个对象包裹着函数所有的变量和其他；

````javascript
//1.正常函数执行
	function show(){
    
	}
	//函数执行之前没有任何的分配空间
	show();//分配
	//之后进行回收

//2.闭包函数执行
	function show(){
	      let a=12;
     //局部变量a仍然会在函数中被利用，所以不会被回收
	      document.onclick=function (){
  	      alert(a);
 	     };
 	   }
//3.面试常考的一个闭包函数-->保证每次都弹出各自的i
	window.onload=function (){
	     var aBtn=document.getElementsByTagName('input');
        
 	     for(var i=0;i<aBtn.length;i++){
	        (function (i){
  	        aBtn[i].onclick=function (){
	            alert(i);
	          };
    	    })(i);
     	 }
    	};


````



--------------------------------------------------------------------------------

ES6的模块化
没有模块 -> CMD -> AMD -> ES6语言提供的模块化支持

--------------------------------------------------------------------------------

ES6的模块化 -> webpack -> 浏览器还不支持

--------------------------------------------------------------------------------

ES6模块化

webpack
npm i webpack -g

--------------------------------------------------------------------------------

webpack编译：
1.entry——入口地址
2.output——输出
  path：绝对路径
  filename：文件名
3.mode——模式
4.所有当前路径前面加./

--------------------------------------------------------------------------------

export
  export let a=xx;
  export const a=xx;

  export function xxx(){

  };

  export class xxx{

  }

  export {xxx, xxx, xxx, ...};

  export default xx;

  //从另一个模块导出
  export * from './m2';
  export {x,x,x,x} from './m2';
  export {default} from './m2';

import
  import * as mod from "./xxx";
  import {a, b, c, ...} from "./xxx";

  //引入默认成员
  import xxx from './mod';

  //模块的代码引入进来，不引入内部成员
  import "./1.jpg";
  import "./1.css";

  //异步引入
  let promise=import("./mod1");